%% Obstacle Avoidance code

%% Setup
clc; clear;
syms l1 l2 l3 d1 d2 d3 theta1 theta2 theta3 real


l = [1245 685 685]; %Link Lengths set 1
DH =    [l1 d1 0 0;
        l2 0 0 theta2;
        l3 0 0 theta3];
bot = manipulator(DH,l);

numJoints = 3;

%Potential Field Parameters 

F_att = zeros(numJoints,numJoints);           %Force from attractive field on a given joint
F_rep = zeros(numJoints,numJoints);           %Force from repulsive field on a given joint
q = [];                         %Current Position in 3D space

%Tunable Parameters
alpha = [10, pi/32, pi/32];              %Defines step size
epsilon = 10;
%epsilon = [1, pi/16, pi/16];            %Region of Convergence ->
zeta = [100 5 5];                         %Constant to be tuned for strengh of attractive field on a given joint 
nu = [1 1 1];                           %Constant to be tuned for strength of repulsive field on a given joint
d = 15;                                  %Distance that defines transition from conic to parabolic well
rho = 15;                                %Region of influence -> Distance that defines if repulsive forces act on a joint

tau = [];              %Torques acting on joints
step = [];             %Step size for each loop

obs =   [1225 770 550        %Centrifuge
        1225 770 550];              %Flask

path = 1;

%Changes which flask is treated as an obstacle 
if path == 1
    %In path 1, flask 2 is treated as obstacle
    obs(2,:) = [1225 970 500];      %Flask 2 - Obstacle
    pos_start = [1225 770 550];      %Flask 1 - Starting Position
    pos_goal = [1225 750 1640];     %Goal
else
    %In path 2, flask 1 is treated as obstacle
    obs(2,:) = [1225 770 550];      %Flask 1 - Obstacle
    pos_start = [1225 970 500];      %Flask 2 - Starting Position
    pos_goal = [1225 1000 2000];    %Goal
end

[d1_start, theta2_start, theta3_start] = bot.ikine(pos_start);
[d1_goal, theta2_goal, theta3_goal] = bot.ikine(pos_goal);

% Choose elbow-up or elbow-down solution (column 1 or 2)
% Using first solution (index 1) for both theta2 and theta3
q_current = [d1_start, theta2_start(1), theta3_start(1)];  % [d1, theta2, theta3]
q_target = [d1_goal, theta2_goal(1), theta3_goal(1)];

[T, A_Mats] = bot.fkine();
T = eval(T);
%J = bot.Jacobian();




%Preallocate space for 3, 3x3 matrices for the velocity jacobian for every
%origin
%3 rows (for velocity jacobian) x 3 columns (numJoints) x 3 matrices (for each origin = numjoint)
%J = zeros(3,numJoints,numJoints);
bot.Jacobian();
[J,O,z] = Jv(bot);
path_points = [];


%% Execution


while norm(q_current - q_target) > epsilon
    norm(q_current - q_target);
    abs(q_current - q_target)

   %Apply force field to each joint
   
   for joint = 1:numJoints
     
        % Get the position of every origin for every time step
        [origin_start, origin_next] = getOrigin(O(:,joint+1),q_current,q_target)
        
    
        % Attractive Forces
        
        F_att(:,joint) = Attractive_Forces(origin_start, origin_next, d, zeta(joint))
       
        % Repulsive Forces
        F_rep(:,joint) = Repulsive_Force(pos_start,obs,rho,nu(joint),origin_start)
        
        %Calculate resultant torque/force on each joints
        
        tau(joint) = torques(F_att(:,joint), F_rep(:,joint), J(:,joint))
        
        

   end


    step = tau/norm(tau);
    q_current = q_current + step'.*alpha; 
   
   [Trans, ~] = bot.fkine(q_current);
   pos_start = Trans(1:3,4)';
   pos_start = eval(pos_start);
   path_points = [path_points; pos_start];   % record EE position each step

end
path_points;
plotPath(path_points, pos_start, pos_goal, obs);





%% Functions

%Function to get the current and next origin for a joint
function [origin_start, origin_next] = getOrigin(O,q_current, q_target)
   syms d1 theta2 theta3
    
    %If there's nothing to substitue this try/catch will solve that. 
    try
        
        origin_start = eval(subs(O,[d1, theta2, theta3],q_current));
        origin_next = eval(subs(O,[d1, theta2, theta3],q_target));
    catch
        origin_start = O;
        origin_next = O;
    end
    
end

%Function that returns attractive force on each joint
function F_att = Attractive_Forces(origin_start, origin_next, d, zeta)
    %Origin_start, Origin_next: 3x1
    %zeta: scalar
    if norm(origin_start - origin_next) <= d
        F_att = -zeta*(origin_start - origin_next); %Parabolic
    else
        F_att = -d*zeta*((origin_start - origin_next)/norm(origin_start - origin_next)); %Conic
    end
        
end


function F_rep = Repulsive_Force(pos, obs, rho, nu, origin_start)
    % pos: 1x3 current EE position
    % obs: Nx3 obstacle positions
    % rho: influence distance
    % nu: scalar
    F_rep = zeros(3,1);
%If the position of the EE if within the bounds of an obstacle 
    if norm(pos(1,:) - obs(1,:)) <= rho
        %CONFIRM THIS FUNCTION. I AM NOT SURE IF I DID THIS RIGHT 
        F_rep(:,joint) = nu*((1/norm(origin_start-obs(1,:))) - (1/rho))*(1/norm(origin_start-obs(1,:))^2)*((origin_start - obs(1,:))/norm(origin_start - obs(1,:))); 
    else if norm(pos(1,:) - obs(2,:)) <= rho
        F_rep(:,joint) = F_rep(:,joint) + nu*((1/norm(origin_start-obs(1,:))) - (1/rho))*(1/norm(origin_start-obs(1,:))^2)*((origin_start - obs(1,:))/norm(origin_start - obs(1,:)));
    else
        F_rep(:,joint) = 0; 
    end
    
end


function tau = torques(F_att, F_rep,J)
        
    %J = bot.Jacobian(q);
    
    
    %Figure out how to set jacobians in this equation
    %tau_att = transpose(J)*transpose(F_att);
    %tau_rep = transpose(J)*transpose(F_rep);
    
    %tau = tau_att + tau_rep;

    % F_att_joint, F_rep_joint: 3x1
    % J: 3x3 velocity Jacobian for this joint
    tau = J.' * (F_att + F_rep);


end

function [J, O, z] = Jv(bot)
    
    z = sym(zeros(3, bot.numJoints + 1));
    O = sym(zeros(3, bot.numJoints + 1));

    %Setting up variables for calculating jacobians
    O(:,2) = simplify(bot.A_Mats(1:3,4,1))
    O(:,3) = simplify(bot.A_Mats(1:3,4,2))
    O(:,4) = simplify(bot.A_Mats(1:3,4,3))
    z(:,1) = [0;0;1]
    z(:,2) = simplify(bot.A_Mats(1:3,3,1))
    z(:,3) = simplify(bot.A_Mats(1:3,3,2))
    z(:,4) = simplify(bot.A_Mats(1:3,3,3))
    

    J(:,:,1) = [cross(z(:,1),O(:,2)), [0;0;0], [0;0;0]];
    J(:,:,2) = [cross(z(:,1),O(:,3)), cross(z(:,2),(O(:,3)-O(:,2))), [0;0;0]];
    J(:,:,3) = [cross(z(:,1),O(:,4)), cross(z(:,2),(O(:,4)-O(:,2))), cross(z(:,3),(O(:,4)-O(:,3)))];

end

function plotPath(path_points, pos_start, pos_goal, obs)
    % --- Coordinate swap for visualization (Z <-> X)
    path_points = path_points(:, [3 2 1]);
    pos_start   = pos_start([3 2 1]);
    pos_goal    = pos_goal([3 2 1]);
    obs         = obs(:, [3 2 1]);

    % --- Figure setup
    figure('Name','Manipulator Path (3D)','NumberTitle','off');
    hold on;
    grid on;
    axis equal;
    view(45, 30);
    xlabel('X (mm)');
    ylabel('Y (mm)');
    zlabel('Z (mm)');
    title('Manipulator End-Effector Path in 3D');

    % --- Plot static elements
    if ~isempty(obs)
        scatter3(obs(:,1), obs(:,2), obs(:,3), 120, 'k', 'filled', 'DisplayName','Obstacles');
    end
    scatter3(pos_start(1), pos_start(2), pos_start(3), 100, 'g', 'filled', 'DisplayName','Start');
    scatter3(pos_goal(1), pos_goal(2), pos_goal(3), 100, 'r', 'filled', 'DisplayName','Goal');

    % --- Path line
    plot3(path_points(:,1), path_points(:,2), path_points(:,3), ...
          'b-', 'LineWidth', 2, 'DisplayName','EE Path');

    % --- Animate End-Effector
    if size(path_points,1) > 1
        hEE = scatter3(path_points(1,1), path_points(1,2), path_points(1,3), ...
                       80, 'b', 'filled', 'DisplayName','End-Effector');
        for i = 2:size(path_points,1)
            if ~isvalid(hEE), break; end
            set(hEE, 'XData', path_points(i,1), ...
                     'YData', path_points(i,2), ...
                     'ZData', path_points(i,3));
            drawnow limitrate;
            pause(0.02);
        end
    end

    legend('Location','bestoutside');
end
