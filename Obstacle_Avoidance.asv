%% Obstacle Avoidance code - FIXED VERSION

%% Setup
clc; clear;
syms l1 l2 l3 d1 d2 d3 theta1 theta2 theta3 real

l = [1245 685 685]; %Link Lengths set 1
DH = [l1 d1 0 0;
      l2 0 0 theta2;
      l3 0 0 theta3];
bot = manipulator(DH,l);

numJoints = 3;

%Tunable Parameters
alpha = [2, 0.1, 0.1];              % Step size for each joint
epsilon = 10;                       % Convergence tolerance (mm)
zeta = [200 50 50];                 % Attractive field strength (increased for EE)
nu = [10 10 10];                    % Repulsive field strength (reduced)
d = 100;                            % Transition distance for attractive field
rho = 50;                          % Region of influence for repulsive field

% Obstacle positions
obs = [1225 770 550;                % Centrifuge
       1225 770 550];               % Flask (will be updated)

path = 1;

% Set start and goal positions based on path
if path == 1
    obs(2,:) = [1225 970 500];      % Flask 2 - Obstacle
    pos_start = [1225 770 550];     % Flask 1 - Starting Position
    pos_goal = [1225 750 1640];     % Goal
else
    obs(2,:) = [1225 770 550];      % Flask 1 - Obstacle
    pos_start = [1225 970 500];     % Flask 2 - Starting Position
    pos_goal = [1225 1000 2000];    % Goal
end

% Calculate starting and goal joint angles
[d1_start, theta2_start, theta3_start] = bot.ikine(pos_start);
[d1_goal, theta2_goal, theta3_goal] = bot.ikine(pos_goal);

% Choose elbow-up or elbow-down solution
q_current = [d1_start, theta2_start(1), theta3_start(1)];
q_target = [d1_goal, theta2_goal(1), theta3_goal(1)];

% Initialize Jacobian to set up bot properties
bot.Jacobian();

% Get origins and z-axes
[J_all, O, z] = Jv(bot);

% Storage
path_points = [];
iteration = 0;
max_iterations = 5000;

fprintf('Starting obstacle avoidance...\n');
fprintf('Initial config: [%.2f, %.4f, %.4f]\n', q_current(1), q_current(2), q_current(3));
fprintf('Target config: [%.2f, %.4f, %.4f]\n', q_target(1), q_target(2), q_target(3));
fprintf('Initial distance: %.2f\n\n', norm(q_current - q_target));

%% Execution Loop

pos_error = inf;  % Initialize task space error

while pos_error > epsilon && iteration < max_iterations
    iteration = iteration + 1;
    
    % Get current EE position
    [Trans, ~] = bot.fkine(q_current);
    pos_current = Trans(1:3,4)';
    pos_current = double(pos_current);
    path_points = [path_points; pos_current];
    
    % Calculate task space error
    pos_error = norm(pos_current - pos_goal);
    
    % Initialize force arrays
    F_att = zeros(3, numJoints);
    F_rep = zeros(3, numJoints);
    tau = zeros(1, numJoints);
    
    % Apply force field to each joint
    for joint = 1:numJoints
        % Get current and goal origins for this joint
        [origin_current, origin_goal] = getOrigin(O(:,joint+1), q_current, q_target);
        
        % Attractive Forces
        F_att(:,joint) = Attractive_Forces(origin_current, origin_goal, d, zeta(joint));
        
        % Repulsive Forces
        F_rep(:,joint) = Repulsive_Force(origin_current, obs, rho, nu(joint));
        
        % Calculate torques using Jacobian for this joint
        J_joint = getJacobian(J_all, q_current, joint);
        tau_vec = torques(F_att(:,joint), F_rep(:,joint), J_joint);
        tau(joint) = tau_vec(joint);  % Extract only this joint's torque component
    end
    
    % Normalize and scale step
    tau_norm = norm(tau);
    if tau_norm > 0
        step = (tau / tau_norm) .* alpha;
    else
        step = zeros(1, numJoints);
    end
    
    % Update joint positions
    q_current = q_current + step;
    
    % Print progress
    if mod(iteration, 100) == 0
        fprintf('Iteration %d: Position error = %.2f mm, Joint error = %.4f\n', ...
                iteration, pos_error, norm(q_current - q_target));
    end
end

fprintf('\nFinished after %d iterations\n', iteration);
fprintf('Final config: [%.2f, %.4f, %.4f]\n', q_current(1), q_current(2), q_current(3));
fprintf('Final position error: %.2f mm\n', pos_error);
fprintf('Current position: [%.2f, %.2f, %.2f]\n', pos_current(1), pos_current(2), pos_current(3));
fprintf('Goal position: [%.2f, %.2f, %.2f]\n', pos_goal(1), pos_goal(2), pos_goal(3));

% Add final position
[Trans, ~] = bot.fkine(q_current);
pos_final = double(Trans(1:3,4)');
path_points = [path_points; pos_final];

plotPath(path_points, pos_start, pos_goal, obs);

%% Functions

function [origin_current, origin_goal] = getOrigin(O_sym, q_current, q_target)
    syms d1 theta2 theta3
    
    % Substitute current joint values
    try
        origin_current = double(subs(O_sym, [d1, theta2, theta3], q_current));
    catch
        origin_current = double(O_sym);
    end
    
    % Substitute goal joint values
    try
        origin_goal = double(subs(O_sym, [d1, theta2, theta3], q_target));
    catch
        origin_goal = double(O_sym);
    end
end

function F_att = Attractive_Forces(origin_current, origin_goal, d, zeta)
    % Compute attractive force
    diff = origin_current - origin_goal;
    dist = norm(diff);
    
    if dist <= d
        % Parabolic well
        F_att = -zeta * diff;
    else
        % Conic well
        F_att = -d * zeta * (diff / dist);
    end
end

function F_rep = Repulsive_Force(origin_joint, obs, rho, nu)
    % Compute repulsive force from all obstacles
    F_rep = zeros(3,1);
    
    for i = 1:size(obs, 1)
        diff = origin_joint - obs(i,:)';
        dist = norm(diff);
        
        if dist <= rho && dist > 1e-3  % Avoid division by zero
            % Repulsive gradient
            magnitude = nu * (1/dist - 1/rho) * (1/dist^2);
            F_rep = F_rep + magnitude * (diff / dist);
        end
    end
end

function tau = torques(F_att, F_rep, J)
    % Compute torque contribution
    % F_att, F_rep: 3x1 vectors
    % J: 3x3 Jacobian
    tau = J' * (F_att + F_rep);
end

function [J_all, O, z] = Jv(bot)
    % Compute velocity Jacobians for each joint
    syms d1 theta2 theta3 l1 l2 l3
    
    % Initialize
    z = sym(zeros(3, bot.numJoints + 1));
    O = sym(zeros(3, bot.numJoints + 1));
    J_all = sym(zeros(3, bot.numJoints, bot.numJoints));
    
    % Base frame
    z(:,1) = [0;0;1];
    O(:,1) = [0;0;0];
    
    % Build cumulative transformation matrices
    T = sym(eye(4));
    for i = 1:bot.numJoints
        T = T * bot.A_Mats(:,:,i);
        O(:,i+1) = simplify(T(1:3,4));
        z(:,i+1) = simplify(T(1:3,3));
    end
    
    % Substitute link lengths
    O = subs(O, [l1, l2, l3], [bot.links(1), bot.links(2), bot.links(3)]);
    z = subs(z, [l1, l2, l3], [bot.links(1), bot.links(2), bot.links(3)]);
    
    % Build Jacobians for each joint origin
    for joint_idx = 1:bot.numJoints
        for col = 1:bot.numJoints
            if col <= joint_idx
                % This joint affects the current joint's position
                if bot.config(col) == "P"
                    % Prismatic joint
                    J_all(:,col,joint_idx) = z(:,col);
                else
                    % Revolute joint
                    J_all(:,col,joint_idx) = cross(z(:,col), O(:,joint_idx+1) - O(:,col));
                end
            else
                % Later joints don't affect this joint's position
                J_all(:,col,joint_idx) = [0;0;0];
            end
        end
        J_all(:,:,joint_idx) = simplify(J_all(:,:,joint_idx));
    end
end

function J_numeric = getJacobian(J_all, q_current, joint_idx)
    % Extract and evaluate Jacobian for a specific joint
    syms d1 theta2 theta3
    
    J_sym = J_all(:,:,joint_idx);
    J_numeric = double(subs(J_sym, [d1, theta2, theta3], q_current));
end

function plotPath(path_points, pos_start, pos_goal, obs)
    % Coordinate swap for visualization (Z <-> X)
    path_points = path_points(:, [3 2 1]);
    pos_start = pos_start([3 2 1]);
    pos_goal = pos_goal([3 2 1]);
    obs = obs(:, [3 2 1]);

    % Figure setup
    figure('Name','Manipulator Path (3D)','NumberTitle','off');
    hold on;
    grid on;
    axis equal;
    view(45, 30);
    xlabel('Z (mm)');
    ylabel('Y (mm)');
    zlabel('X (mm)');
    title('Manipulator End-Effector Path with Obstacle Avoidance');

    % Plot obstacles with influence spheres
    for i = 1:size(obs,1)
        [x_s, y_s, z_s] = sphere(20);
        surf(obs(i,1) + 250*x_s, obs(i,2) + 250*y_s, obs(i,3) + 250*z_s, ...
             'FaceColor', 'r', 'FaceAlpha', 0.1, 'EdgeColor', 'none', 'HandleVisibility', 'off');
    end
    
    % Plot static elements
    scatter3(obs(:,1), obs(:,2), obs(:,3), 120, 'k', 'filled', 'DisplayName','Obstacles');
    scatter3(pos_start(1), pos_start(2), pos_start(3), 150, 'g', '^', 'filled', 'LineWidth', 2, 'DisplayName','Start');
    scatter3(pos_goal(1), pos_goal(2), pos_goal(3), 150, 'r', 'pentagram', 'filled', 'LineWidth', 2, 'DisplayName','Goal');

    % Path line
    if size(path_points,1) > 1
        plot3(path_points(:,1), path_points(:,2), path_points(:,3), ...
              'b-', 'LineWidth', 3, 'DisplayName','EE Path');
        
        % Mark final position
        scatter3(path_points(end,1), path_points(end,2), path_points(end,3), ...
                 120, 'c', 'o', 'filled', 'DisplayName','Final Position');
    end

    % Animate End-Effector
    if size(path_points,1) > 1
        hEE = scatter3(path_points(1,1), path_points(1,2), path_points(1,3), ...
                       100, 'b', 'filled', 'DisplayName','Current Position');
        for i = 2:10:size(path_points,1)  % Every 10th point
            if ~isvalid(hEE), break; end
            set(hEE, 'XData', path_points(i,1), ...
                     'YData', path_points(i,2), ...
                     'ZData', path_points(i,3));
            drawnow limitrate;
            pause(0.01);
        end
        % Final position
        set(hEE, 'XData', path_points(end,1), ...
                 'YData', path_points(end,2), ...
                 'ZData', path_points(end,3));
    end

    legend('Location','bestoutside');
end